{"version":3,"file":"index.js","sources":["../../src/setBatchUpdatesFn.ts","../../src/QueryClient.ts","../../src/QueryClientProvider.tsx","../../src/utils.ts","../../src/createBaseQuery.ts","../../src/createQuery.ts","../../src/useIsFetching.ts","../../src/createInfiniteQuery.ts","../../src/createMutation.ts","../../src/useIsMutating.ts","../../src/createQueries.ts"],"sourcesContent":["import { notifyManager } from '@tanstack/query-core'\nimport { batch } from 'solid-js'\n\nnotifyManager.setBatchNotifyFunction(batch)\n","import type {\n  QueryClientConfig as QueryCoreClientConfig,\n  DefaultOptions as CoreDefaultOptions,\n  QueryObserverOptions as QueryCoreObserverOptions,\n  InfiniteQueryObserverOptions as QueryCoreInfiniteQueryObserverOptions,\n  DefaultError,\n  QueryKey,\n} from '@tanstack/query-core'\nimport { QueryClient as QueryCoreClient } from '@tanstack/query-core'\n\nexport interface QueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = never,\n> extends Omit<\n    QueryCoreObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >,\n    'structuralSharing'\n  > {\n  /**\n   * Set this to a reconciliation key to enable reconciliation between query results.\n   * Set this to `false` to disable reconciliation between query results.\n   * Set this to a function which accepts the old and new data and returns resolved data of the same type to implement custom reconciliation logic.\n   * Defaults reconciliation key to `id`.\n   */\n  reconcile?:\n    | string\n    | false\n    | ((oldData: TData | undefined, newData: TData) => TData)\n}\n\nexport interface InfiniteQueryObserverOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends Omit<\n    QueryCoreInfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >,\n    'structuralSharing'\n  > {\n  /**\n   * Set this to a reconciliation key to enable reconciliation between query results.\n   * Set this to `false` to disable reconciliation between query results.\n   * Set this to a function which accepts the old and new data and returns resolved data of the same type to implement custom reconciliation logic.\n   * Defaults reconciliation key to `id`.\n   */\n  reconcile?:\n    | string\n    | false\n    | ((oldData: TData | undefined, newData: TData) => TData)\n}\n\nexport interface DefaultOptions<TError = DefaultError>\n  extends CoreDefaultOptions<TError> {\n  queries?: QueryObserverOptions<unknown, TError>\n}\n\nexport interface QueryClientConfig extends QueryCoreClientConfig {\n  defaultOptions?: DefaultOptions\n}\n\nexport class QueryClient extends QueryCoreClient {\n  constructor(config: QueryClientConfig = {}) {\n    super(config)\n  }\n}\n","import type { QueryClient } from './QueryClient'\nimport type { JSX } from 'solid-js'\nimport { createContext, useContext, onMount, onCleanup } from 'solid-js'\n\nexport const QueryClientContext = createContext<QueryClient | undefined>(\n  undefined,\n)\n\nexport const useQueryClient = (queryClient?: QueryClient) => {\n  if (queryClient) {\n    return queryClient\n  }\n  const client = useContext(QueryClientContext)\n\n  if (!client) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return client\n}\n\nexport type QueryClientProviderProps = {\n  client: QueryClient\n  children?: JSX.Element\n}\n\nexport const QueryClientProvider = (\n  props: QueryClientProviderProps,\n): JSX.Element => {\n  onMount(() => {\n    props.client.mount()\n  })\n  onCleanup(() => props.client.unmount())\n\n  return (\n    <QueryClientContext.Provider value={props.client}>\n      {props.children}\n    </QueryClientContext.Provider>\n  )\n}\n","export function shouldThrowError<T extends (...args: any[]) => boolean>(\n  throwError: boolean | T | undefined,\n  params: Parameters<T>,\n): boolean {\n  // Allow throwError function to override throwing behavior on a per-error basis\n  if (typeof throwError === 'function') {\n    return throwError(...params)\n  }\n\n  return !!throwError\n}\n","/* eslint-disable @typescript-eslint/no-unnecessary-condition */\n// Had to disable the lint rule because isServer type is defined as false\n// in solid-js/web package. I'll create a GitHub issue with them to see\n// why that happens.\nimport type {\n  Query,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n  QueryState,\n} from '@tanstack/query-core'\nimport type { QueryClient } from './QueryClient'\nimport { hydrate, notifyManager } from '@tanstack/query-core'\nimport type { Accessor } from 'solid-js'\nimport { isServer } from 'solid-js/web'\nimport {\n  createComputed,\n  createMemo,\n  createResource,\n  on,\n  onCleanup,\n} from 'solid-js'\nimport { createStore, reconcile, unwrap } from 'solid-js/store'\nimport { useQueryClient } from './QueryClientProvider'\nimport type { CreateBaseQueryOptions } from './types'\nimport { shouldThrowError } from './utils'\n\nfunction reconcileFn<TData, TError>(\n  store: QueryObserverResult<TData, TError>,\n  result: QueryObserverResult<TData, TError>,\n  reconcileOption:\n    | string\n    | false\n    | ((oldData: TData | undefined, newData: TData) => TData),\n): QueryObserverResult<TData, TError> {\n  if (reconcileOption === false) return result\n  if (typeof reconcileOption === 'function') {\n    const newData = reconcileOption(store.data, result.data as TData)\n    return { ...result, data: newData } as typeof result\n  }\n  const newData = reconcile(result.data, { key: reconcileOption })(store.data)\n  return { ...result, data: newData } as typeof result\n}\n\ntype HydrateableQueryState<TData, TError> = QueryObserverResult<TData, TError> &\n  QueryState<TData, TError>\n\n/**\n * Solid's `onHydrated` functionality will silently \"fail\" (hydrate with an empty object)\n * if the resource data is not serializable.\n */\nconst hydrateableObserverResult = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n  T2,\n>(\n  query: Query<TQueryFnData, TError, TData, TQueryKey>,\n  result: QueryObserverResult<T2, TError>,\n): HydrateableQueryState<T2, TError> => {\n  // Including the extra properties is only relevant on the server\n  if (!isServer) return result as HydrateableQueryState<T2, TError>\n\n  return {\n    ...unwrap(result),\n\n    // cast to refetch function should be safe, since we only remove it on the server,\n    // and refetch is not relevant on the server\n    refetch: undefined as unknown as HydrateableQueryState<\n      T2,\n      TError\n    >['refetch'],\n\n    // hydrate() expects a QueryState object, which is similar but not\n    // quite the same as a QueryObserverResult object. Thus, for now, we're\n    // copying over the missing properties from state in order to support hydration\n    dataUpdateCount: query.state.dataUpdateCount,\n    fetchFailureCount: query.state.fetchFailureCount,\n    isInvalidated: query.state.isInvalidated,\n\n    // Unsetting these properties on the server since they might not be serializable\n    fetchFailureReason: null,\n    fetchMeta: null,\n  }\n}\n\n// Base Query Function that is used to create the query.\nexport function createBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: Accessor<\n    CreateBaseQueryOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>\n  >,\n  Observer: typeof QueryObserver,\n  queryClient?: Accessor<QueryClient>,\n) {\n  type ResourceData =\n    | HydrateableQueryState<TData, TError>\n    | QueryObserverResult<TData, TError>\n\n  const client = createMemo(() => useQueryClient(queryClient?.()))\n\n  const defaultedOptions = client().defaultQueryOptions(options())\n  defaultedOptions._optimisticResults = 'optimistic'\n  defaultedOptions.structuralSharing = false\n  if (isServer) {\n    defaultedOptions.retry = false\n    defaultedOptions.throwOnError = true\n  }\n  const observer = new Observer(client(), defaultedOptions)\n\n  const [state, setState] = createStore<QueryObserverResult<TData, TError>>(\n    observer.getOptimisticResult(defaultedOptions),\n  )\n\n  const createServerSubscriber = (\n    resolve: (\n      data: ResourceData | PromiseLike<ResourceData | undefined> | undefined,\n    ) => void,\n    reject: (reason?: any) => void,\n  ) => {\n    return observer.subscribe((result) => {\n      notifyManager.batchCalls(() => {\n        const query = observer.getCurrentQuery()\n        const unwrappedResult = hydrateableObserverResult(query, result)\n\n        if (unwrappedResult.isError) {\n          reject(unwrappedResult.error)\n        } else {\n          resolve(unwrappedResult)\n        }\n      })()\n    })\n  }\n\n  const createClientSubscriber = () => {\n    return observer.subscribe((result) => {\n      notifyManager.batchCalls(() => {\n        // @ts-expect-error - This will error because the reconcile option does not\n        // exist on the query-core QueryObserverResult type\n        const reconcileOptions = observer.options.reconcile\n        // If the query has data we dont suspend but instead mutate the resource\n        // This could happen when placeholderData/initialData is defined\n        if (queryResource()?.data && result.data && !queryResource.loading) {\n          setState((store) => {\n            return reconcileFn(\n              store,\n              result,\n              reconcileOptions === undefined ? 'id' : reconcileOptions,\n            )\n          })\n          mutate(state)\n        } else {\n          setState((store) => {\n            return reconcileFn(\n              store,\n              result,\n              reconcileOptions === undefined ? 'id' : reconcileOptions,\n            )\n          })\n          refetch()\n        }\n      })()\n    })\n  }\n\n  /**\n   * Unsubscribe is set lazily, so that we can subscribe after hydration when needed.\n   */\n  let unsubscribe: (() => void) | null = null\n\n  const [queryResource, { refetch, mutate }] = createResource<\n    ResourceData | undefined\n  >(\n    () => {\n      return new Promise((resolve, reject) => {\n        if (isServer) {\n          unsubscribe = createServerSubscriber(resolve, reject)\n        } else {\n          if (!unsubscribe) {\n            unsubscribe = createClientSubscriber()\n          }\n        }\n\n        if (!state.isLoading) {\n          const query = observer.getCurrentQuery()\n          resolve(hydrateableObserverResult(query, state))\n        }\n      })\n    },\n    {\n      initialValue: state,\n\n      // If initialData is provided, we resolve the resource immediately\n      ssrLoadFrom: options().initialData ? 'initial' : 'server',\n\n      get deferStream() {\n        return options().deferStream\n      },\n\n      /**\n       * If this resource was populated on the server (either sync render, or streamed in over time), onHydrated\n       * will be called. This is the point at which we can hydrate the query cache state, and setup the query subscriber.\n       *\n       * Leveraging onHydrated allows us to plug into the async and streaming support that solidjs resources already support.\n       *\n       * Note that this is only invoked on the client, for queries that were originally run on the server.\n       */\n      onHydrated(_k, info) {\n        if (info.value) {\n          hydrate(client(), {\n            queries: [\n              {\n                queryKey: defaultedOptions.queryKey,\n                queryHash: defaultedOptions.queryHash,\n                state: info.value,\n              },\n            ],\n          })\n        }\n\n        if (!unsubscribe) {\n          /**\n           * Do not refetch query on mount if query was fetched on server,\n           * even if `staleTime` is not set.\n           */\n          const newOptions = { ...defaultedOptions }\n          if (defaultedOptions.staleTime || !defaultedOptions.initialData) {\n            newOptions.refetchOnMount = false\n          }\n          // Setting the options as an immutable object to prevent\n          // wonky behavior with observer subscriptions\n          observer.setOptions(newOptions)\n          setState(observer.getOptimisticResult(newOptions))\n          unsubscribe = createClientSubscriber()\n        }\n      },\n    },\n  )\n\n  onCleanup(() => {\n    if (unsubscribe) {\n      unsubscribe()\n      unsubscribe = null\n    }\n  })\n\n  createComputed(\n    on(\n      () => client().defaultQueryOptions(options()),\n      () => observer.setOptions(client().defaultQueryOptions(options())),\n      {\n        // Defer because we don't need to trigger on first render\n        // This only cares about changes to options after the observer is created\n        defer: true,\n      },\n    ),\n  )\n\n  createComputed(\n    on(\n      () => state.status,\n      () => {\n        if (\n          state.isError &&\n          !state.isFetching &&\n          shouldThrowError(observer.options.throwOnError, [\n            state.error,\n            observer.getCurrentQuery(),\n          ])\n        ) {\n          throw state.error\n        }\n      },\n    ),\n  )\n\n  const handler = {\n    get(\n      target: QueryObserverResult<TData, TError>,\n      prop: keyof QueryObserverResult<TData, TError>,\n    ): any {\n      const val = queryResource()?.[prop]\n      return val !== undefined ? val : Reflect.get(target, prop)\n    },\n  }\n\n  return new Proxy(state, handler)\n}\n","import type { QueryKey, DefaultError } from '@tanstack/query-core'\nimport { QueryObserver } from '@tanstack/query-core'\nimport type { QueryClient } from './QueryClient'\nimport type { Accessor } from 'solid-js'\nimport { createMemo } from 'solid-js'\nimport { createBaseQuery } from './createBaseQuery'\nimport type {\n  CreateQueryOptions,\n  CreateQueryResult,\n  DefinedCreateQueryResult,\n  FunctionedParams,\n  SolidQueryOptions,\n} from './types'\n\ntype UndefinedInitialDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = FunctionedParams<\n  SolidQueryOptions<TQueryFnData, TError, TData, TQueryKey> & {\n    initialData?: undefined\n  }\n>\n\ntype DefinedInitialDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = FunctionedParams<\n  SolidQueryOptions<TQueryFnData, TError, TData, TQueryKey> & {\n    initialData: TQueryFnData | (() => TQueryFnData)\n  }\n>\n\nexport function queryOptions<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>\n\nexport function queryOptions<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n): DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>\n\nexport function queryOptions(options: unknown) {\n  return options\n}\n\nexport function createQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: () => QueryClient,\n): CreateQueryResult<TData, TError>\n\nexport function createQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: () => QueryClient,\n): DefinedCreateQueryResult<TData, TError>\nexport function createQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: Accessor<QueryClient>,\n) {\n  return createBaseQuery(\n    createMemo(() => options()),\n    QueryObserver,\n    queryClient,\n  )\n}\n","import type { QueryFilters } from '@tanstack/query-core'\nimport type { QueryClient } from './QueryClient'\nimport type { Accessor } from 'solid-js'\nimport { createMemo, createSignal, onCleanup } from 'solid-js'\nimport { useQueryClient } from './QueryClientProvider'\n\nexport function useIsFetching(\n  filters?: Accessor<QueryFilters>,\n  queryClient?: Accessor<QueryClient>,\n): Accessor<number> {\n  const client = createMemo(() => useQueryClient(queryClient?.()))\n  const queryCache = createMemo(() => client().getQueryCache())\n\n  const [fetches, setFetches] = createSignal(client().isFetching(filters?.()))\n\n  const unsubscribe = queryCache().subscribe(() => {\n    setFetches(client().isFetching(filters?.()))\n  })\n\n  onCleanup(unsubscribe)\n\n  return fetches\n}\n","import type {\n  QueryObserver,\n  QueryKey,\n  DefaultError,\n  InfiniteData,\n} from '@tanstack/query-core'\nimport type { QueryClient } from './QueryClient'\nimport { InfiniteQueryObserver } from '@tanstack/query-core'\nimport type {\n  CreateInfiniteQueryOptions,\n  CreateInfiniteQueryResult,\n} from './types'\nimport { createBaseQuery } from './createBaseQuery'\nimport { createMemo } from 'solid-js'\nimport type { Accessor } from 'solid-js'\n\nexport function createInfiniteQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: CreateInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  queryClient?: Accessor<QueryClient>,\n): CreateInfiniteQueryResult<TData, TError> {\n  return createBaseQuery(\n    createMemo(() => options()),\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    InfiniteQueryObserver as typeof QueryObserver,\n    queryClient,\n  ) as CreateInfiniteQueryResult<TData, TError>\n}\n","import type { DefaultError } from '@tanstack/query-core'\nimport type { QueryClient } from './QueryClient'\nimport { MutationObserver } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  CreateMutateFunction,\n  CreateMutationOptions,\n  CreateMutationResult,\n} from './types'\nimport type { Accessor } from 'solid-js'\nimport { createComputed, onCleanup, on } from 'solid-js'\nimport { createStore } from 'solid-js/store'\nimport { shouldThrowError } from './utils'\n\n// HOOK\nexport function createMutation<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: CreateMutationOptions<TData, TError, TVariables, TContext>,\n  queryClient?: Accessor<QueryClient>,\n): CreateMutationResult<TData, TError, TVariables, TContext> {\n  const client = useQueryClient(queryClient?.())\n\n  const observer = new MutationObserver<TData, TError, TVariables, TContext>(\n    client,\n    options(),\n  )\n\n  const mutate: CreateMutateFunction<TData, TError, TVariables, TContext> = (\n    variables,\n    mutateOptions,\n  ) => {\n    observer.mutate(variables, mutateOptions).catch(noop)\n  }\n\n  const [state, setState] = createStore<\n    CreateMutationResult<TData, TError, TVariables, TContext>\n  >({\n    ...observer.getCurrentResult(),\n    mutate,\n    mutateAsync: observer.getCurrentResult().mutate,\n  })\n\n  createComputed(() => {\n    observer.setOptions(options())\n  })\n\n  createComputed(\n    on(\n      () => state.status,\n      () => {\n        if (\n          state.isError &&\n          shouldThrowError(observer.options.throwOnError, [state.error])\n        ) {\n          throw state.error\n        }\n      },\n    ),\n  )\n\n  const unsubscribe = observer.subscribe((result) => {\n    setState({\n      ...result,\n      mutate,\n      mutateAsync: result.mutate,\n    })\n  })\n\n  onCleanup(unsubscribe)\n\n  return state\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n","import type { MutationFilters } from '@tanstack/query-core'\nimport type { QueryClient } from './QueryClient'\nimport { useQueryClient } from './QueryClientProvider'\nimport type { Accessor } from 'solid-js'\nimport { createSignal, onCleanup, createMemo } from 'solid-js'\n\nexport function useIsMutating(\n  filters?: Accessor<MutationFilters>,\n  queryClient?: Accessor<QueryClient>,\n): Accessor<number> {\n  const client = createMemo(() => useQueryClient(queryClient?.()))\n  const mutationCache = createMemo(() => client().getMutationCache())\n\n  const [mutations, setMutations] = createSignal(\n    client().isMutating(filters?.()),\n  )\n\n  const unsubscribe = mutationCache().subscribe((_result) => {\n    setMutations(client().isMutating(filters?.()))\n  })\n\n  onCleanup(unsubscribe)\n\n  return mutations\n}\n","import type {\n  QueriesPlaceholderDataFunction,\n  QueryFunction,\n  QueryKey,\n  DefaultError,\n  QueriesObserverOptions,\n} from '@tanstack/query-core'\nimport { notifyManager, QueriesObserver } from '@tanstack/query-core'\nimport type { QueryClient } from './QueryClient'\nimport type { Accessor } from 'solid-js'\nimport { createComputed, onCleanup } from 'solid-js'\nimport { createStore, unwrap } from 'solid-js/store'\nimport { useQueryClient } from './QueryClientProvider'\nimport type { CreateQueryResult, SolidQueryOptions } from './types'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// `placeholderData` function does not have a parameter\ntype CreateQueryOptionsForCreateQueries<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = Omit<\n  SolidQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  'placeholderData'\n> & {\n  placeholderData?: TQueryFnData | QueriesPlaceholderDataFunction<TQueryFnData>\n}\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? CreateQueryOptionsForCreateQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? CreateQueryOptionsForCreateQueries<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? CreateQueryOptionsForCreateQueries<unknown, TError, TData>\n    : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n    T extends [infer TQueryFnData, infer TError, infer TData]\n    ? CreateQueryOptionsForCreateQueries<TQueryFnData, TError, TData>\n    : T extends [infer TQueryFnData, infer TError]\n    ? CreateQueryOptionsForCreateQueries<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? CreateQueryOptionsForCreateQueries<TQueryFnData>\n    : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n        select: (data: any) => infer TData\n      }\n    ? CreateQueryOptionsForCreateQueries<TQueryFnData, Error, TData, TQueryKey>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey> }\n    ? CreateQueryOptionsForCreateQueries<\n        TQueryFnData,\n        Error,\n        TQueryFnData,\n        TQueryKey\n      >\n    : // Fallback\n      CreateQueryOptionsForCreateQueries\n\ntype GetResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? CreateQueryResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n    ? CreateQueryResult<TQueryFnData, TError>\n    : T extends { data: infer TData; error?: infer TError }\n    ? CreateQueryResult<TData, TError>\n    : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n    T extends [any, infer TError, infer TData]\n    ? CreateQueryResult<TData, TError>\n    : T extends [infer TQueryFnData, infer TError]\n    ? CreateQueryResult<TQueryFnData, TError>\n    : T extends [infer TQueryFnData]\n    ? CreateQueryResult<TQueryFnData>\n    : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n    T extends {\n        queryFn?: QueryFunction<unknown, any>\n        select: (data: any) => infer TData\n      }\n    ? CreateQueryResult<TData>\n    : T extends { queryFn?: QueryFunction<infer TQueryFnData, any> }\n    ? CreateQueryResult<TQueryFnData>\n    : // Fallback\n      CreateQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? CreateQueryOptionsForCreateQueries[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetOptions<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesOptions<[...Tail], [...Result, GetOptions<Head>], [...Depth, 1]>\n  : unknown[] extends T\n  ? T\n  : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n  // use this to infer the param types in the case of Array.map() argument\n  T extends CreateQueryOptionsForCreateQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      infer TQueryKey\n    >[]\n  ? CreateQueryOptionsForCreateQueries<TQueryFnData, TError, TData, TQueryKey>[]\n  : // Fallback\n    CreateQueryOptionsForCreateQueries[]\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends any[],\n  Result extends any[] = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? CreateQueryResult[]\n  : T extends []\n  ? []\n  : T extends [infer Head]\n  ? [...Result, GetResults<Head>]\n  : T extends [infer Head, ...infer Tail]\n  ? QueriesResults<[...Tail], [...Result, GetResults<Head>], [...Depth, 1]>\n  : T extends CreateQueryOptionsForCreateQueries<\n      infer TQueryFnData,\n      infer TError,\n      infer TData,\n      any\n    >[]\n  ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n    CreateQueryResult<\n      unknown extends TData ? TQueryFnData : TData,\n      unknown extends TError ? DefaultError : TError\n    >[]\n  : // Fallback\n    CreateQueryResult[]\n\nexport function createQueries<\n  T extends any[],\n  TCombinedResult = QueriesResults<T>,\n>(\n  queriesOptions: Accessor<{\n    queries: readonly [...QueriesOptions<T>]\n    combine?: (result: QueriesResults<T>) => TCombinedResult\n  }>,\n  queryClient?: Accessor<QueryClient>,\n): TCombinedResult {\n  const client = useQueryClient(queryClient?.())\n\n  const defaultedQueries = queriesOptions().queries.map((options) => {\n    const defaultedOptions = client.defaultQueryOptions(options)\n    defaultedOptions._optimisticResults = 'optimistic'\n    return defaultedOptions\n  })\n\n  const observer = new QueriesObserver(\n    client,\n    defaultedQueries,\n    queriesOptions().combine\n      ? ({\n          combine: queriesOptions().combine,\n        } as QueriesObserverOptions<TCombinedResult>)\n      : undefined,\n  )\n\n  // @ts-expect-error - Types issue with solid-js createStore\n  const [state, setState] = createStore<TCombinedResult>(\n    observer.getOptimisticResult(defaultedQueries)[1](),\n  )\n\n  const unsubscribe = observer.subscribe((result) => {\n    notifyManager.batchCalls(() => {\n      setState(unwrap(result) as unknown as TCombinedResult)\n    })()\n  })\n\n  onCleanup(unsubscribe)\n\n  createComputed(() => {\n    const updatedQueries = queriesOptions().queries.map((options) => {\n      const defaultedOptions = client.defaultQueryOptions(options)\n      defaultedOptions._optimisticResults = 'optimistic'\n      return defaultedOptions\n    })\n    observer.setQueries(\n      updatedQueries,\n      queriesOptions().combine\n        ? ({\n            combine: queriesOptions().combine,\n          } as QueriesObserverOptions<TCombinedResult>)\n        : undefined,\n      { listeners: false },\n    )\n  })\n\n  return state\n}\n"],"names":["notifyManager","setBatchNotifyFunction","batch","QueryClient","QueryCoreClient","constructor","config","QueryClientContext","createContext","undefined","useQueryClient","queryClient","client","useContext","Error","QueryClientProvider","props","onMount","mount","onCleanup","unmount","_$createComponent","Provider","value","children","shouldThrowError","throwError","params","reconcileFn","store","result","reconcileOption","newData","data","reconcile","key","hydrateableObserverResult","query","isServer","unwrap","refetch","dataUpdateCount","state","fetchFailureCount","isInvalidated","fetchFailureReason","fetchMeta","createBaseQuery","options","Observer","createMemo","defaultedOptions","defaultQueryOptions","_optimisticResults","structuralSharing","retry","throwOnError","observer","setState","createStore","getOptimisticResult","createServerSubscriber","resolve","reject","subscribe","batchCalls","getCurrentQuery","unwrappedResult","isError","error","createClientSubscriber","reconcileOptions","queryResource","loading","mutate","unsubscribe","createResource","Promise","isLoading","initialValue","ssrLoadFrom","initialData","deferStream","onHydrated","_k","info","hydrate","queries","queryKey","queryHash","newOptions","staleTime","refetchOnMount","setOptions","createComputed","on","defer","status","isFetching","handler","get","target","prop","val","Reflect","Proxy","queryOptions","createQuery","QueryObserver","useIsFetching","filters","queryCache","getQueryCache","fetches","setFetches","createSignal","createInfiniteQuery","InfiniteQueryObserver","createMutation","MutationObserver","variables","mutateOptions","catch","noop","getCurrentResult","mutateAsync","useIsMutating","mutationCache","getMutationCache","mutations","setMutations","isMutating","_result","createQueries","queriesOptions","defaultedQueries","map","QueriesObserver","combine","updatedQueries","setQueries","listeners"],"mappings":"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"}